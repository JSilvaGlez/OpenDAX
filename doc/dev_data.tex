\chapter{Dealing with Data}
The basic unit of data in OpenDAX is the \textit{Tag}.  A tag is similar to a variable in a programming language.
\section{Data Types}
Tags can be one of 15 different data types in OpenDax.  These are given in the following table.

\begin{tabular}{|l|l|l|l|l|}
\hline \textbf{Name} & \textbf{Description} & \textbf{Size (bits)} & \textbf{Min} & \textbf{Max} \\
\hline BOOL & Boolean (True/False) & 1 & 0 & 1 \\
\hline BYTE & Bit String & 8 & 0 & 255 \\
\hline SINT & Signed Short Integer & 8 & -128 & 127 \\
\hline WORD & Bit String & 16 & 0 & 65,535 \\
\hline INT & Signed Integer & 16 & -32,768 & 32,767 \\
\hline UINT & Unsigned Integer & 16 & 0 & 65,535 \\
\hline DWORD & Bit String & 32 & 0 & 4,294,967,296 \\
\hline DINT & Double Integer & 32 & -2,147,483,648 & 2,147,483,647 \\
\hline UDINT & Unsigned Double Integer & 32 & 0 & 4,294,967,296 \\
\hline TIME & Unix Timestamp & 32 &  &  \\
\hline REAL & IEC 754 Floating Point & 32 &  &  \\
\hline LWORD & Bit String & 64 & 0 & $2^{64}$ \\
\hline LINT & Long Integer & 64 & $-2^{63}$ & $2^{63}-1$ \\
\hline ULINT & Unsigned Long Integer & 64 & 0 & $2^{64}$ \\
\hline LREAL & IEC 754 Double Floating Point & 64 &  &  \\
\hline 
\end{tabular}
 
The opendax.h header file contains the definitions for these data types.  These definitions are the name of the data type in the above table prefixed with "\texttt{DAX\_}".  So to represent a Boolean data type to the OpenDAX library you would use the definition \texttt{DAX\_BOOL}.  These definitions are used anytime your module needs to communicate a data type to the OpenDAX library.  For example, when creating a tag the module has to specify the data type.  You could create an INT tag with a call like this...

\begin{verbatim}
dax_add_tag("MyInt", DAX_INT, 1);
\end{verbatim}

This would create a tag in the server with the name \textit{MyInt} of type INT.  The 1 as the last argument just means a single member.  A larger number would signify an array.

There are also some typedefs in opendax.h that help with declaring variables within you module code.  They are the same as the precompiler defines except they are all lower case.  These make sure that the variable definitions inside your module match the data types of the tags in OpenDAX.  For the above Tag you could create a variable in C with this code...

\begin{verbatim}
dax_int myInt;
myInt = 13000;
\end{verbatim}

Each Tag in OpenDAX can be a single value of any of these base data types or it can be an array of these.  

\begin{verbatim}
dax_add_tag("MyInt", DAX_INT, 10);
\end{verbatim}

This code would generate an array of INT's in the Server.  It is important to note that tags can be redefined as long as they data type stays the same.  If you call dax\_add\_tag() again with a count that is higher than the previous call it would increase the size of the array.  If you call it with a count smaller than the previous, it will ignore it and keep the array the same size.  If you change the data type in the second call the function will return an error.

OpenDAX also supports the concept of a \textit{Compound Data Type}\index{Compound Data Type}.  This is an aggregate data type that is very similar to a structure in C.  Your module can create a new compound data type or it can use ones that are created by other modules.

These are the four functions that we will need to use from the libdax library.

\begin{verbatim}
dax_cdt *dax_cdt_new(char *name, int *error);

int dax_cdt_member(dax_state *ds, dax_cdt *cdt, char *name,
                   tag_type mem_type, unsigned int count);

int dax_cdt_create(dax_state *ds, dax_cdt *cdt, tag_type *type);

void dax_cdt_free(dax_cdt *cdt);
\end{verbatim}

To create a CDT you first have to allocate a CDT object.

The \verb|dax_cdt_new()|\index{dax\_cdt\_new() function} allocates, initializes and returns a pointer to a new CDT object.  The \textit{name} argument is the name that would be given to the CDT.  The \textit{error} argument is a pointer to an integer that can indicate any errors.  If there is an error the function will return NULL and the integer pointed to \textit{error} will be set to the error code.  If you are not interested in this error code then you can pass NULL to the function.

Once you have the object you add members to the CDT one at a time.  These members can be of any previously defined data type including other CDTs.  They can also be arrays and even arrays of other CDT's.  We do this with the \verb|dax_cdt_member()|\index{dax\_cdt\_member() function}.  The \textit{cdt} argument is the object that was returned from the \verb|dax_cdt_new()| function.  The \textit{name} argument is the name that we want to give to our member.  The \textit{mem\_type} argument is either one of the 15 base DAX\_* datatypes from above or a predefined compound data type.

Once all of the members have been added the module the \verb|dax_cdt_create()|\index{dax\_cdt\_create() function} function is used to send the data type definition to the server and actually create the data type.  The \textit{type} argument to \verb|dax_cdt_create()| will contain the new type identifier of the created compound data type.  This identifier can be used anywhere another data type definition (such as DAX\_DINT) could be used.

The \verb|dax_cdt_free()|\index{dax\_cdt\_free() function} function simply frees the memory associated with the new data type.  Don't try to free the memory yourself because there are other data structures in the \verb|dax_cdt| object that have to be freed.  Simply passing the pointer to \verb|free()| for example will result in a memory leak.  Once the data type has been created it can be freed.  Obviously failure to do this will also result in a memory leak.  Don't try to reuse a \verb|dax_cdt| object either.  You can reuse the pointer but you need to free the old one with \verb|dax_cdt_free()| and then reallocate a new one with \verb|dax_cdt_new()|.

Perhaps it's time for an example.  Let's build a CDT that has the following structure...

\begin{verbatim}
MyCDT
  MyInteger INT
  MyReals   REAL[10]
  MyBools   BOOL[8]
\end{verbatim}

The following code would be used\ldots
\begin{verbatim}
dax_cdt *dc;
int error;
tag_type type;

dc = dax_new("MyCDT", &error);
if(dc == NULL) {
    printf("Error code returned is %d\n", error);
    //handle error
} else {
    dax_cdt_member(ds, dc, "MyInteger", DAX_INT, 1);
    dax_cdt_member(ds, dc, "MyReals", DAX_REAL, 10);
    dax_cdt_member(ds, dc, "MyBools", DAX_BOOL, 8);

    error = dax_cdt_create(ds, dc, &type);
    if(error) {
        printf("Error returned from dax_cdt_member() is %d\n", error);
	    //handle error
    } else {
        printf("CDT created!  Data Type = 0x%X\n", type);
    }
    dax_cdt_free(dc);
}

\end{verbatim}

This code will build the above CDT.  There is some error checking missing on the return values of \verb|dax_cdt_member()| functions but this is for clarity.  In your code you would want to check these return values.  Also be careful of the error handling so that you don't exit this code before the \verb|dax_cdt_free()| function has been called to free the \verb|dax_cdt| object.

\section{Creating Tags}

\section{Reading Data}

\section{Writing Data}
