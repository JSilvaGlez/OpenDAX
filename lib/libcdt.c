/*  OpenDAX - An open source data acquisition and control system
 *  Copyright (c) 2009 Phil Birkelbach
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 *
 * This is the source file for Custom Data Type handling code in the library
 */

#include <libdax.h>
#include <dax/libcommon.h>
#include <ctype.h>

/* The main datatype array for the module */
static datatype *_datatypes;
static unsigned int _datatype_size;

/* This defines the starting size of the datatype array.
 * It is also the amount that the datatype array will 
 * grow when necessary */
#ifndef DAX_DATATYPE_SIZE
# define DAX_DATATYPE_SIZE 8
#endif

/* Inserts the given datatype into the array */
static int
_insert_type(int index, char *typename) {
    /* Right now all we are doing is checking that the name isn't
     * too big.  We are assuming that the server hasn't sent us a
     * name that is malformed. */
    if(strlen(typename) <= DAX_TAGNAME_SIZE) {
        _datatypes[index].name = strdup(typename);
    }
    if(_datatypes[index].name == NULL) {
        return ERR_ALLOC;
    }
    return 0;
}
    
/* Adds the member that is described by the string desc.  This string
 * would look like the one generated by the serialize_datatype() function
 * in the server.  The index is the array index in _datatypes[] */
static int
_add_member(int index, char *desc) {
    char *str, *last;
    char *name, *type;
    int count;
    cdt_member *new, *this;
    
    name = type = NULL;
    count = 0;
    
    new = malloc(sizeof(cdt_member));
    if(new == NULL) {
        return ERR_ALLOC;
    }
    
    //--printf("Member string = '%s'\n", desc);    
    name = strtok_r(desc, ",", &last);
    if(name) {
        type = strtok_r(NULL, ",", &last);
        if(type) {
            str = strtok_r(NULL, ",", &last);
            if(str) {
                count = (int)strtol(str, (char **)NULL, 10);
            }
        }
    }
    
    /* TODO: Need to do some error checking here */
    if(name && type && (count > 0)) {
        new->name = strdup(name);
        new->type = dax_string_to_type(type);
        new->count = count;
        new->next = NULL;
        //--printf("_add_member() - name = %s type = 0x%X count = %ld\n", new->name, new->type, new->count);
        /* Add the new member to the end of the linked list */
        this = _datatypes[index].members;
        if(this == NULL) {
            _datatypes[index].members = new;
        } else {
            while(this->next != NULL) this = this->next;
            this->next = new;
        }
    } else {
        free(new);
        return ERR_ARG;
    }
    
    return 0;
}

/* Calculate the size (in bytes) of the datatype */
int
get_typesize(tag_type type)
{
    int size = 0;
    unsigned int pos = 0; /* Bit position within the data area */
    cdt_member *this;

    if( dax_type_to_string(type) == NULL )
        return ERR_ARG;
    
    if(IS_CUSTOM(type)) {
        this = _datatypes[CDT_TO_INDEX(type)].members;
        while (this != NULL) {
            if(this->type == DAX_BOOL) {
                pos += this->count; /* BOOLs are easy just add the number of bits */
            } else {
                /* Since it's not a bool we need to align to the next byte. 
                 * To align it we set all the lower three bits to 1 and then
                 * increment. */
                if(pos % 8 != 0) { /* Do nothing if already aligned */
                    pos |= 0x07;
                    pos++;
                }
                if(IS_CUSTOM(this->type)) {
                    pos += (get_typesize(this->type) * this->count) * 8;
                } else {
                    /* This gets the size in bits */
                    pos += TYPESIZE(this->type) * this->count;
                }
            }
            this = this->next;
        }
        if(pos) {
            size = (pos - 1)/8 + 1;
        } else {
            size = 0;
        }
    } else { /* Not IS_CUSTOM() */
        size = TYPESIZE(type) / 8; /* Size in bytes */
    }
    return size;
}

/* Retrieves a pointer to the datatype array element identified by type 
 * returns NULL on failure and if the error pointer is not NULL the error
 * code will be placed there. */
datatype *
get_cdt_pointer(tag_type type, int *error)
{
    int index;
    int result;
    
    if(error != NULL) *error = 0;
    if(IS_CUSTOM(type)) {
        index = CDT_TO_INDEX(type);
        if(index < _datatype_size && _datatypes[index].name != NULL) {
            return &_datatypes[index];
        } else {
            result = dax_cdt_get(type, NULL);
            if(result == 0) {
                return &_datatypes[index]; 
            } else {
                if(error != NULL) *error = result;
            }
            return NULL;
        }
    } else {
        return NULL;
    }
}

/* Adds the given type to the array cache.  'type' is the type id
 * and typedesc is the type description string that would be generated
 * by a call to serialize_datatype() in the server. */
int
add_cdt_to_cache(tag_type type, char *typedesc)
{
    int index, result, n;
    char *str, *last;
    
    index = CDT_TO_INDEX(type);
    
    if(_datatype_size == 0) { /* Make sure we have an array */
        /* Allocate the datatype array and set the initial counters */
        _datatypes = malloc(sizeof(datatype) * DAX_DATATYPE_SIZE);
        if(_datatypes == NULL) {
            return ERR_ALLOC;
        }
        /* Set both pointers to NULL */
        for(n = 0; n < DAX_DATATYPE_SIZE; n++) {
            _datatypes[n].name = NULL;
            _datatypes[n].members = NULL;
        }
        _datatype_size = DAX_DATATYPE_SIZE;
    }
    
    /* Do we need to grow the array */
    while(index >= _datatype_size) { 
        /* Allocate more space for the array */
        datatype *new_datatype;
        
        new_datatype = realloc(_datatypes, (_datatype_size + DAX_DATATYPE_SIZE) * sizeof(datatype));

        if(new_datatype != NULL) {
            _datatypes = new_datatype;
            /* Set both pointers to NULL */
            for(n = _datatype_size; n < _datatype_size + DAX_DATATYPE_SIZE; n++) {
                _datatypes[n].name = NULL;
                _datatypes[n].members = NULL;
            }
            _datatype_size += DAX_DATATYPE_SIZE;
        } else {
            return ERR_ALLOC;
        }
    }
    
    /* At this point we should have the spot for the datatype */
    str = strtok_r(typedesc, ":", &last);
    if(str == NULL) {
        dax_error("add_cdt_to_cache(): Something is seriously wrong with the string");
        return ERR_ARG;
    }
    //--printf("typename = '%s'\n", str);
    result = _insert_type(index, str);
    
    while( (str = strtok_r(NULL, ":", &last)) ) {
        result = _add_member(index, str);
        if(result) return result;
    }
    return 0;
}

/* Creates an empty Custom Datatype with 'name' if
 * 'error' is non NULL then results are put there. 
 * Returns NULL on error and a pointer to the new
 * datatype if successfull.
 */

dax_cdt *
dax_cdt_new(char *name, int *error)
{
    int result = 0;
    dax_cdt *new = NULL;
    
    if(strlen(name) > DAX_TAGNAME_SIZE) {
        result = ERR_2BIG;
    } else {
        new = malloc(sizeof(dax_cdt *));
        if(new == NULL) {
            result = ERR_ALLOC;
        } else {
            new->members = NULL;
            new->name = strdup(name);
            if(new->name == NULL) {
                free(new);
                new = NULL;
                result = ERR_ALLOC;
            }
        }
    }
    if(result != 0 && error != NULL) {
        *error = result;
    }
    
    return new;
}


/* Adds a member to the Custom Datatype. */
int
dax_cdt_member(dax_cdt *cdt, char *name, tag_type type, unsigned int count)
{
    cdt_member *new = NULL, *this, *last;
     
    /* Duplicate Check */
    this = cdt->members;
    while(this != NULL) {
        last = this;
        if(strcmp(name, this->name) == 0) return ERR_DUPL;
        this = this->next;
    }
    /* Valid type check */
    if(dax_type_to_string(type) == NULL) return ERR_ARG;
    /* Size check */
    if(strlen(name) > DAX_TAGNAME_SIZE) return ERR_2BIG;
    
    /* Allocate the new member */
    new = malloc(sizeof(cdt_member));
    if(new == NULL) return ERR_ALLOC;
    
    /* Assign values */
    new->name = strdup(name);
    if(new->name == NULL) return ERR_ALLOC;
    new->type = type;
    new->count = count;
    new->next = NULL;
    
    /* Put it in the linked list */
    if(cdt->members == NULL) cdt->members = new;
    else last->next = new;
    
    return 0;
}



/* Find the datatype that has the name 'type' and return it's numeric ID 
 * returns 0 on error.  */
tag_type
dax_string_to_type(char *type)
{
    int result, n;
    //--printf("dax_string_to_type() - Looking for type %s\n", type);
    //--usleep(500000);
    if(!strcasecmp(type, "BOOL"))  return DAX_BOOL;
    if(!strcasecmp(type, "BYTE"))  return DAX_BYTE;
    if(!strcasecmp(type, "SINT"))  return DAX_SINT;
    if(!strcasecmp(type, "WORD"))  return DAX_WORD;
    if(!strcasecmp(type, "INT"))   return DAX_INT;
    if(!strcasecmp(type, "UINT"))  return DAX_UINT;
    if(!strcasecmp(type, "DWORD")) return DAX_DWORD;
    if(!strcasecmp(type, "DINT"))  return DAX_DINT;
    if(!strcasecmp(type, "UDINT")) return DAX_UDINT;
    if(!strcasecmp(type, "TIME"))  return DAX_TIME;
    if(!strcasecmp(type, "REAL"))  return DAX_REAL;
    if(!strcasecmp(type, "LWORD")) return DAX_LWORD;
    if(!strcasecmp(type, "LINT"))  return DAX_LINT;
    if(!strcasecmp(type, "ULINT")) return DAX_ULINT;
    if(!strcasecmp(type, "LREAL")) return DAX_LREAL;
    
    /* See if we already have it in the cache */
    for(n = 0; n<_datatype_size; n++) {
        if(_datatypes[n].name != NULL && !strcasecmp(type, _datatypes[n].name)) {
            return CDT_TO_TYPE(n);
        }
    }
    
    /* If not go to the server for it */
    result = dax_cdt_get(0, type);

    if(result) {
        return 0;
    } else {
        /* Search Again - It'll be there this time */
        for(n = 0; n < _datatype_size; n++) {
            if(_datatypes[n].name != NULL && !strcasecmp(type, _datatypes[n].name)) {
                return CDT_TO_TYPE(n);
            }
        }
    }
    /* We should have found it by now.  If not return error */
    return 0;
}

/* Returns a pointer to a string that is the name of the datatype */
const char *
dax_type_to_string(tag_type type)
{
    int index;
    
    /* TODO: Could replace this with a call to get_cdt_pointer() */
    if(IS_CUSTOM(type)) {
        index = CDT_TO_INDEX(type);
        if(index < _datatype_size && _datatypes[index].name != NULL) {
            return _datatypes[index].name;
        } else {
            if(!dax_cdt_get(type, NULL)) {
                return _datatypes[index].name; 
            }
            return NULL;
        }
    } else {   
        switch (type) {
            case DAX_BOOL:
                return "BOOL";
            case DAX_BYTE:
                return "BYTE";
            case DAX_SINT:
                return "SINT";
            case DAX_WORD:
                return "WORD";
            case DAX_INT:
                return "INT";
            case DAX_UINT:
                return "UINT";
            case DAX_DWORD:
                return "DWORD";
            case DAX_DINT:
                return "DINT";
            case DAX_UDINT:
                return "UDINT";
            case DAX_TIME:
                return "TIME";
            case DAX_REAL:
                return "REAL";
            case DAX_LWORD:
                return "LWORD";
            case DAX_LINT:
                return "LINT";
            case DAX_ULINT:
                return "ULINT";
            case DAX_LREAL:
                return "LREAL";
        }
    }
    return NULL;
}

#define STATE_NAME     0x01
#define STATE_INDEX    0x02
#define STATE_IDLE     0x03
#define STATE_NEXT     0x04
#define STATE_FINISHED 0x00

#define TEST_SIZE 10

typedef struct {
    char name[DAX_TAGNAME_SIZE + 1];
    int index;
    tag_type type;
    int count;
    int byte;
    int bit;
} _member_def;


static int
_parse_tagname(_member_def *list, char *str, int count)
{
    int n = 0, i = 0, j = 0, idx = 0;
    int state = STATE_NAME;
    char name[DAX_TAGNAME_SIZE + 1];
    char test[TEST_SIZE];
    int index = 0;
    
    /* Initialize the list */
    for(n = 0; n < count; n++) {
        list[n].name[0] = '\0';
        list[n].index = -1;    
    }
    n = 0;
    
    while(str[n] != '\0' && state) {
        if(state == STATE_NAME) {          /* We start with tag searching state */
            if(str[n] == '[') {
                state = STATE_INDEX;      /* If we find a '[' switch to finding index */
            } else if(str[n] == '.') {
                state = STATE_NEXT;      /* If we find a '.' switch to the next name */
            } else {  /* Otherwise write the character to the tagname */
                if(n > DAX_TAGNAME_SIZE) { /* Check size */
                    return ERR_2BIG;
                }
                name[j++] = str[n];
                name[j] = '\0'; /* Just to make sure we have a NULL end */
            }
            if(str[n+1] == '\0') state = STATE_FINISHED;
            if(state != STATE_NAME) { /* If we have found the end of the tagname */
                strncpy(list[idx].name, name, DAX_TAGNAME_SIZE);
            }
        } else if(state == STATE_INDEX) { /* In this state we get the index */
            if(str[n] == '\0') {
                return ERR_PARSE;
            } else if(i > TEST_SIZE) {
                return ERR_2BIG;
            } else if(str[n] == ']') { /* get the index from the string */
                test[i] = '\0';
                list[idx].index = (int)strtol(test, NULL, 10);
                state = STATE_IDLE; /* This is so we'll go through the loop again */
            } else if(!isdigit(str[n])) { /* Only Positive Integers are allowed */
                return ERR_NOTNUMBER;
            } else {
                if(i>=TEST_SIZE) { /* Too big for string */
                    return ERR_ARG;
                }
                test[i++] = str[n]; /* Add another character to the test string */
                test[i] = '\0';
            }
        } else if(state == STATE_NEXT) {
            idx++;
            i = j = 0;
            if(idx >= count) {
                return ERR_PARSE;
            }
            n--; /* Because this causes us one extra pass through the loop */
            state = STATE_NAME;
            
        /* We should only be idle for one character.  The only characters that
         * should follow the index are a '.' or the ending NULL.  If it's the
         * NULL we shouldn't ever get here.  If it's not the '.' then it's an error */
        } else if(state == STATE_IDLE) {
            if(str[n] == '.') {
                state = STATE_NEXT;
            } else {
                return ERR_ARG;
            }
        }
        n++;
    }
    /* Zero length tagname no good */
    if(n == 0) return ERR_TAG_BAD;
    
    /* Test the index that we found */
    if(index < 0) {
        return ERR_ARG;
    }

    return 0;
}

/* This function is used to determine a handle to the tag data area given
 * by the string.  It is a state machine of sorts.  It starts out looking for
 * the tagname itself.  Once it finds the end of the tagname it will either
 * have to find an index between brackets [] or a sub member following a '.'
 * It adds up all the indexes, makes sure that they are all within the bounds
 * of the tag and the datatype and then returns zero if successful and an
 * error code otherwise.
 */

int
dax_tag_handle(Handle *h, char *str, int count)
{
    int n = 0;
    int cnt = 1;
    int result, index;
    _member_def *list = NULL;
    dax_tag tag;
    cdt_member *this;
    tag_type type;
    
    /* TEST TEST TEST */
    //--printf("Getting Handle for '%s' with count = %d\n", str, count);
       
    /* Count the number of '.'s to figure out the size of the list */
    while(str[n] != '\0') {
        if(str[n] == '.') {
            cnt++;
        }
        n++;
    }
    list = malloc(sizeof(_member_def) * cnt);
    if(list == NULL) {
        return ERR_ALLOC;
    }
    
    /* parse the given string into tokens and place in list */
    result = _parse_tagname(list, str, cnt);
    if(result) goto getout;
    /* At this point 'list' should be populated with all the members of the 
     * tag string.  Now we fill in the datatypes and the byte offsets */
    
    /* First PASS - Fill in all the bytes and bits for each member */
    for(n = 0; n < cnt; n++) {
        list[n].byte = list[n].bit = 0;
        
        if(n == 0) { /* This should be the tagname */
            result = dax_tag_byname(&tag, list[0].name);
            if(result) goto getout;
            list[n].type = tag.type;  
            list[n].count = tag.count;
        } else { /* all the members of the tag */
            type = list[n-1].type; /* We are looking inside the last members type */
            if(IS_CUSTOM(type)) { /* Get the new members datatype */
                /* We do this just to make sure that our type is in the cache */
                if(dax_type_to_string(type) == NULL) {
                    result = ERR_ARG;
                    goto getout;
                }
                /* If we make it this far then our type should work */
                index = CDT_TO_INDEX(type);
                this = _datatypes[index].members;
            
                while(this != NULL) {
                    /* Start by adding all the bytes of the members before the
                     * one we are looking for */
                    if(strcasecmp(list[n].name, this->name)) {
                        if(this->type == DAX_BOOL) {
                            list[n].byte += (this->count - 1)/8 + 1;
                        } else {
                            list[n].byte += get_typesize(this->type) * this->count;
                        }
                    } else { /* When we find it */
                        list[n].type = this->type;
                        list[n].count = this->count;
                        if(list[n].index >= 0 && list[n].index >= this->count) {
                            result = ERR_2BIG;
                            goto getout;
                        }
                        break;
                    }
                    this = this->next;
                } /* while(this != NULL */
                if(this == NULL ) {
                    result = ERR_NOTFOUND;
                    goto getout;
                }
            } else {
                result = ERR_ARG; /* Datatype of previous member is not custom */
                goto getout;
            } /* if(IS_CUSTOM) */
        } /* if(first item in list) */
        /* The only time that we are allowed to leave the index off of a data member
         * in the tagname string is if the count of the type (or tag) is 1 or if we are
         * the last one in the list, in which case we'll return for the whole array */
        if(list[n].count > 1 && list[n].index < 0 && n != cnt-1) {
            result = ERR_ARBITRARY;
            goto getout;
        }
        
        if(list[n].index >= 0) {
            if(list[n].type == DAX_BOOL) {
                list[n].byte += list[n].index / 8;
                list[n].bit += list[n].index % 8;
            } else {
                list[n].byte += get_typesize(list[n].type) * list[n].index;
                list[n].bit += 0;
            } 
        }
        //--printf("list[%d]: .name = %s :.index = %d :.type = %s :.count = %d :.byte = %d :.bit = %d\n", 
        //--        n, list[n].name, list[n].index, dax_type_to_string(list[n].type), list[n].count, list[n].byte, list[n].bit);
    
    } /* First Pass for() loop */
    
    /* Now the second pass where we put it all together */
    h->byte = 0;
    for(n = 0; n < cnt; n++) {
        h->byte += list[n].byte;
    }
    n = cnt-1; /* Set to the last item in the list */
    
    h->index = tag.idx;
    h->bit = list[n].bit;
    h->type = list[n].type;
    if(list[n].index == -1) {
        h->count = list[n].count;
    } else {
        if((list[n].index + count) > list[n].count) {
            result = ERR_2BIG;
            goto getout;
        } else {
            if(count <= 0) {
                h->count = 1;
            } else {
                h->count = count;
            }
        }
    }
    if(list[n].type == DAX_BOOL) {
        h->size = (h->count - 1)/8 + 1;
    } else {
        h->size = get_typesize(list[n].type) * h->count;
    }
    
getout:
    free(list);
    if(result) {
        //--printf("Exiting with error %d\n", result);
        bzero(h, sizeof(*h));
    }
    return result;
}

/* This is the custom datatype iterator.  If type is a datatype then this
 * function iterates over each member of the datatype and calls 'callback'
 * with the cdt_iter structure and passes back the udata pointer as well.
 * If type is 0 then it iterates over the list of datatypes.  In this case
 * the name and type fields in cdt_iter are the only things that are relevant. */
int
dax_cdt_iter(tag_type type, void *udata, void (*callback)(cdt_iter, void *))
{
    datatype *dt;
    cdt_member *this;
    cdt_iter iter;
    int result;
    int byte = 0;
    int bit = 0;
    int index = 0;
    
    if(type == 0) { /* iterate through the custom types */
        dt = get_cdt_pointer(CDT_TO_TYPE(index), &result);
        
        while(result == 0 || result == ERR_INUSE) {
            if(result == 0) {
                iter.name = dt->name;
                iter.type = CDT_TO_TYPE(index);
                iter.count = iter.byte = iter.bit = 0;
                printf("Iterating type %s\n", iter.name);
                callback(iter, udata);
            }
            index++;
            dt = get_cdt_pointer(CDT_TO_TYPE(index), &result); 
        }
    } else { /* iterate over the members */
        dt = get_cdt_pointer(type, &result);
        if(dt == NULL) {
            return result;
        }
        
        this = dt->members;
        while(this != NULL) {
            iter.name = this->name;
            iter.type = this->type;
            iter.count = this->count;
            iter.bit = bit;
            iter.byte = byte;
            callback(iter, udata); /* Call the callback */
            /* No sense in calculating the offsets if we're done */
            if(this->next != NULL) { 
                if(this->type == DAX_BOOL) {
                    bit += this->count % 8;
                    byte += this->count / 8;
                    if(bit > 7) { /* adjust for the overflow */
                        bit %= 8;
                        byte ++;
                    }
                    /* if the next one is not a BOOL then we should align */
                    if(this->next->type != DAX_BOOL && bit != 0) {
                        bit = 0;
                        byte++;
                    }
                } else { /* Not this->type == DAX_BOOL */
                    bit = 0;
                    byte += get_typesize(this->type) * this->count;
                }
            }
            this = this->next;
        }
    }
    return 0;
}
