/*  OpenDAX - An open source data acquisition and control system
 *  Copyright (c) 2009 Phil Birkelbach
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 *
 *
 * This is the source file for Custom Data Type handling code
 */

#include <libdax.h>
#include <dax/libcommon.h>
#include <string.h>


static datatype *_datatypes;
static unsigned int _datatype_size;

#ifndef DAX_DATATYPE_SIZE
# define DAX_DATATYPE_SIZE 8
#endif

static int
_insert_type(int index, char *typename) {
    /* Right now all we are doing is checking that the name isn't
     * too big.  We are assuming that the server hasn't sent us a
     * name that is malformed. */
    if(strlen(typename) <= DAX_TAGNAME_SIZE) {
        _datatypes[index].name = strdup(typename);
    }
    if(_datatypes[index].name == NULL) {
        return ERR_ALLOC;
    }
    return 0;
}
    
/* Adds the member that is described by the string desc.  This string
 * would look like the one generated by the serialize_datatype() function
 * in the server.  The index is the array index in _datatypes[] */
static int
_add_member(int index, char *desc) {
    char *str, *last;
    char *name, *type;
    int count;
    cdt_member *new, *this;
    
    name = type = NULL;
    count = 0;
    
    new = malloc(sizeof(cdt_member));
    if(new == NULL) {
        return ERR_ALLOC;
    }
    
    //--printf("Member string = '%s'\n", desc);    
    name = strtok_r(desc, ",", &last);
    if(name) {
        type = strtok_r(NULL, ",", &last);
        if(type) {
            str = strtok_r(NULL, ",", &last);
            if(str) {
                count = (int)strtol(str, (char **)NULL, 10);
            }
        }
    }
    
    /* TODO: Need to do some error checking here */
    if(name && type && (count > 0)) {
        new->name = strdup(name);
        new->type = dax_string_to_type(type);
        new->count = count;
        new->next = NULL;
        //--printf("_add_member() - name = %s type = 0x%X count = %ld\n", new->name, new->type, new->count);
        /* Add the new member to the end of the linked list */
        this = _datatypes[index].members;
        if(this == NULL) {
            _datatypes[index].members = new;
        } else {
            while(this->next != NULL) this = this->next;
            this->next = new;
        }
    } else {
        free(new);
        return ERR_ARG;
    }
    
    return 0;
}

/* Adds the given type to the array cache.  'type' is the type id
 * and typedesc is the type description string that would be generated
 * by a call to serialize_datatype() in the server. */
int
add_cdt_to_cache(type_t type, char *typedesc)
{
    int index, result, n;
    char *str, *last;
    
    index = CDT_TO_INDEX(type);
    
    if(_datatype_size == 0) { /* Make sure we have an array */
        /* Allocate the datatype array and set the initial counters */
        _datatypes = malloc(sizeof(datatype) * DAX_DATATYPE_SIZE);
        if(_datatypes == NULL) {
            return ERR_ALLOC;
        }
        /* Set both pointers to NULL */
        for(n = 0; n < DAX_DATATYPE_SIZE; n++) {
            _datatypes[n].name = NULL;
            _datatypes[n].members = NULL;
        }
        _datatype_size = DAX_DATATYPE_SIZE;
    }
    
    /* Do we need to grow the array */
    while(index >= _datatype_size) { 
        /* Allocate more space for the array */
        datatype *new_datatype;
        
        new_datatype = realloc(_datatypes, (_datatype_size + DAX_DATATYPE_SIZE) * sizeof(datatype));

        if(new_datatype != NULL) {
            _datatypes = new_datatype;
            /* Set both pointers to NULL */
            for(n = _datatype_size; n < _datatype_size + DAX_DATATYPE_SIZE; n++) {
                _datatypes[n].name = NULL;
                _datatypes[n].members = NULL;
            }
            _datatype_size += DAX_DATATYPE_SIZE;
        } else {
            return ERR_ALLOC;
        }
    }
    
    /* At this point we should have the spot for the datatype */
    str = strtok_r(typedesc, ":", &last);
    if(str == NULL) {
        dax_error("add_cdt_to_cache(): Something is seriously wrong with the string");
        return ERR_ARG;
    }
    //--printf("typename = '%s'\n", str);
    result = _insert_type(index, str);
    
    while( (str = strtok_r(NULL, ":", &last)) ) {
        result = _add_member(index, str);
        if(result) return result;
    }
    return 0;
}

/* This is just a wrapper function that calls dax_cdt_add() with the
 * right parameters to tell the server to finalize the datatype.  Once
 * the datatype is finalized it can't be modified and tags can then be
 * added. */
int
dax_cdt_finalize(type_t type)
{
    /* With a type of 0 dax_cdt_add() will finalize the datatype */
    return dax_cdt_add(type, "NULL", 0, 1);
}

/* Find the datatype that has the name 'type' and return it's numeric ID 
 * returns 0 on error.  */
type_t
dax_string_to_type(char *type)
{
    int result, n;
    
    if(!strcasecmp(type, "BOOL"))  return DAX_BOOL;
    if(!strcasecmp(type, "BYTE"))  return DAX_BYTE;
    if(!strcasecmp(type, "SINT"))  return DAX_SINT;
    if(!strcasecmp(type, "WORD"))  return DAX_WORD;
    if(!strcasecmp(type, "INT"))   return DAX_INT;
    if(!strcasecmp(type, "UINT"))  return DAX_UINT;
    if(!strcasecmp(type, "DWORD")) return DAX_DWORD;
    if(!strcasecmp(type, "DINT"))  return DAX_DINT;
    if(!strcasecmp(type, "UDINT")) return DAX_UDINT;
    if(!strcasecmp(type, "TIME"))  return DAX_TIME;
    if(!strcasecmp(type, "REAL"))  return DAX_REAL;
    if(!strcasecmp(type, "LWORD")) return DAX_LWORD;
    if(!strcasecmp(type, "LINT"))  return DAX_LINT;
    if(!strcasecmp(type, "ULINT")) return DAX_ULINT;
    if(!strcasecmp(type, "LREAL")) return DAX_LREAL;
    
    /* See if we already have it in the cache */
    for(n = 0; n<_datatype_size; n++) {
        if(_datatypes[n].name != NULL && !strcasecmp(type, _datatypes[n].name)) {
            return CDT_TO_TYPE(n);
        }
    }
    
    /* If not got to the server for it */
    result = dax_cdt_get(0, type);
    
    if(result) {
        return 0;
    } else {
        /* Search Again - It'll be there this time */
        for(n = 0; n<_datatype_size; n++) {
            if(_datatypes[n].name != NULL && !strcasecmp(type, _datatypes[n].name)) {
                return CDT_TO_TYPE(n);
            }
        }
    }
    /* We should have found it by now.  If not return error */
    return 0;
}

/* Returns a pointer to a string that is the name of the datatype */
const char *
dax_type_to_string(int type)
{
    int index;
    
    if(IS_CUSTOM(type)) {
        index = CDT_TO_INDEX(type);
        if(index < _datatype_size && _datatypes[index].name != NULL) {
            return _datatypes[index].name;
        } else {
            return NULL;
        }
    } else {   
        switch (type) {
            case DAX_BOOL:
                return "BOOL";
            case DAX_BYTE:
                return "BYTE";
            case DAX_SINT:
                return "SINT";
            case DAX_WORD:
                return "WORD";
            case DAX_INT:
                return "INT";
            case DAX_UINT:
                return "UINT";
            case DAX_DWORD:
                return "DWORD";
            case DAX_DINT:
                return "DINT";
            case DAX_UDINT:
                return "UDINT";
            case DAX_TIME:
                return "TIME";
            case DAX_REAL:
                return "REAL";
            case DAX_LWORD:
                return "LWORD";
            case DAX_LINT:
                return "LINT";
            case DAX_ULINT:
                return "ULINT";
            case DAX_LREAL:
                return "LREAL";
        }
    }
    return NULL;
}

