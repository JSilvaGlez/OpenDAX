/*  OpenDAX - An open source data acquisition and control system
 *  Copyright (c) 2009 Phil Birkelbach
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 *
 *
 * This is the source file for Custom Data Type handling code
 */

#include <libdax.h>
#include <dax/libcommon.h>

/* The main datatype array for the module */
static datatype *_datatypes;
static unsigned int _datatype_size;

/* This defines the starting size of the datatype array.
 * It is also the amount that the datatype array will 
 * grow when necessary */
#ifndef DAX_DATATYPE_SIZE
# define DAX_DATATYPE_SIZE 8
#endif

/* Inserts the given datatype into the array */
static int
_insert_type(int index, char *typename) {
    /* Right now all we are doing is checking that the name isn't
     * too big.  We are assuming that the server hasn't sent us a
     * name that is malformed. */
    if(strlen(typename) <= DAX_TAGNAME_SIZE) {
        _datatypes[index].name = strdup(typename);
    }
    if(_datatypes[index].name == NULL) {
        return ERR_ALLOC;
    }
    return 0;
}
    
/* Adds the member that is described by the string desc.  This string
 * would look like the one generated by the serialize_datatype() function
 * in the server.  The index is the array index in _datatypes[] */
static int
_add_member(int index, char *desc) {
    char *str, *last;
    char *name, *type;
    int count;
    cdt_member *new, *this;
    
    name = type = NULL;
    count = 0;
    
    new = malloc(sizeof(cdt_member));
    if(new == NULL) {
        return ERR_ALLOC;
    }
    
    //--printf("Member string = '%s'\n", desc);    
    name = strtok_r(desc, ",", &last);
    if(name) {
        type = strtok_r(NULL, ",", &last);
        if(type) {
            str = strtok_r(NULL, ",", &last);
            if(str) {
                count = (int)strtol(str, (char **)NULL, 10);
            }
        }
    }
    
    /* TODO: Need to do some error checking here */
    if(name && type && (count > 0)) {
        new->name = strdup(name);
        new->type = dax_string_to_type(type);
        new->count = count;
        new->next = NULL;
        //--printf("_add_member() - name = %s type = 0x%X count = %ld\n", new->name, new->type, new->count);
        /* Add the new member to the end of the linked list */
        this = _datatypes[index].members;
        if(this == NULL) {
            _datatypes[index].members = new;
        } else {
            while(this->next != NULL) this = this->next;
            this->next = new;
        }
    } else {
        free(new);
        return ERR_ARG;
    }
    
    return 0;
}

/* Calculate the size (in bytes) of the datatype */
static int
_get_typesize(type_t type)
{
    int size = 0;
    unsigned int pos = 0; /* Bit position within the data area */
    cdt_member *this;

    if( dax_type_to_string(type) == NULL )
        return ERR_ARG;
    
    if(IS_CUSTOM(type)) {
        this = _datatypes[CDT_TO_INDEX(type)].members;
        while (this != NULL) {
            if(this->type == DAX_BOOL) {
                pos += this->count; /* BOOLs are easy just add the number of bits */
            } else {
                /* Since it's not a bool we need to align to the next byte. 
                 * To align it we set all the lower three bits to 1 and then
                 * increment. */
                if(pos % 8 != 0) { /* Do nothing if already aligned */
                    pos |= 0x07;
                    pos++;
                }
                if(IS_CUSTOM(this->type)) {
                    pos += (_get_typesize(this->type) * this->count) * 8;
                } else {
                    /* This gets the size in bits */
                    pos += TYPESIZE(this->type) * this->count;
                }
            }
            this = this->next;
        }
        if(pos) {
            size = (pos - 1)/8 + 1;
        } else {
            size = 0;
        }
    } else { /* Not IS_CUSTOM() */
        size = TYPESIZE(type) / 8; /* Size in bytes */
    }
    return size;
}

/* Adds the given type to the array cache.  'type' is the type id
 * and typedesc is the type description string that would be generated
 * by a call to serialize_datatype() in the server. */
int
add_cdt_to_cache(type_t type, char *typedesc)
{
    int index, result, n;
    char *str, *last;
    
    index = CDT_TO_INDEX(type);
    
    if(_datatype_size == 0) { /* Make sure we have an array */
        /* Allocate the datatype array and set the initial counters */
        _datatypes = malloc(sizeof(datatype) * DAX_DATATYPE_SIZE);
        if(_datatypes == NULL) {
            return ERR_ALLOC;
        }
        /* Set both pointers to NULL */
        for(n = 0; n < DAX_DATATYPE_SIZE; n++) {
            _datatypes[n].name = NULL;
            _datatypes[n].members = NULL;
        }
        _datatype_size = DAX_DATATYPE_SIZE;
    }
    
    /* Do we need to grow the array */
    while(index >= _datatype_size) { 
        /* Allocate more space for the array */
        datatype *new_datatype;
        
        new_datatype = realloc(_datatypes, (_datatype_size + DAX_DATATYPE_SIZE) * sizeof(datatype));

        if(new_datatype != NULL) {
            _datatypes = new_datatype;
            /* Set both pointers to NULL */
            for(n = _datatype_size; n < _datatype_size + DAX_DATATYPE_SIZE; n++) {
                _datatypes[n].name = NULL;
                _datatypes[n].members = NULL;
            }
            _datatype_size += DAX_DATATYPE_SIZE;
        } else {
            return ERR_ALLOC;
        }
    }
    
    /* At this point we should have the spot for the datatype */
    str = strtok_r(typedesc, ":", &last);
    if(str == NULL) {
        dax_error("add_cdt_to_cache(): Something is seriously wrong with the string");
        return ERR_ARG;
    }
    //--printf("typename = '%s'\n", str);
    result = _insert_type(index, str);
    
    while( (str = strtok_r(NULL, ":", &last)) ) {
        result = _add_member(index, str);
        if(result) return result;
    }
    return 0;
}

/* This is just a wrapper function that calls dax_cdt_add() with the
 * right parameters to tell the server to finalize the datatype.  Once
 * the datatype is finalized it can't be modified and tags can then be
 * added. */
int
dax_cdt_finalize(type_t type)
{
    /* With a type of 0 dax_cdt_add() will finalize the datatype */
    return dax_cdt_add(type, "NULL", 0, 1);
}

/* Find the datatype that has the name 'type' and return it's numeric ID 
 * returns 0 on error.  */
type_t
dax_string_to_type(char *type)
{
    int result, n;
    
    if(!strcasecmp(type, "BOOL"))  return DAX_BOOL;
    if(!strcasecmp(type, "BYTE"))  return DAX_BYTE;
    if(!strcasecmp(type, "SINT"))  return DAX_SINT;
    if(!strcasecmp(type, "WORD"))  return DAX_WORD;
    if(!strcasecmp(type, "INT"))   return DAX_INT;
    if(!strcasecmp(type, "UINT"))  return DAX_UINT;
    if(!strcasecmp(type, "DWORD")) return DAX_DWORD;
    if(!strcasecmp(type, "DINT"))  return DAX_DINT;
    if(!strcasecmp(type, "UDINT")) return DAX_UDINT;
    if(!strcasecmp(type, "TIME"))  return DAX_TIME;
    if(!strcasecmp(type, "REAL"))  return DAX_REAL;
    if(!strcasecmp(type, "LWORD")) return DAX_LWORD;
    if(!strcasecmp(type, "LINT"))  return DAX_LINT;
    if(!strcasecmp(type, "ULINT")) return DAX_ULINT;
    if(!strcasecmp(type, "LREAL")) return DAX_LREAL;
    
    /* See if we already have it in the cache */
    for(n = 0; n<_datatype_size; n++) {
        if(_datatypes[n].name != NULL && !strcasecmp(type, _datatypes[n].name)) {
            return CDT_TO_TYPE(n);
        }
    }
    
    /* If not got to the server for it */
    result = dax_cdt_get(0, type);

    if(result) {
        return 0;
    } else {
        /* Search Again - It'll be there this time */
        for(n = 0; n < _datatype_size; n++) {
            if(_datatypes[n].name != NULL && !strcasecmp(type, _datatypes[n].name)) {
                return CDT_TO_TYPE(n);
            }
        }
    }
    /* We should have found it by now.  If not return error */
    return 0;
}

/* Returns a pointer to a string that is the name of the datatype */
const char *
dax_type_to_string(int type)
{
    int index;
    
    if(IS_CUSTOM(type)) {
        index = CDT_TO_INDEX(type);
        if(index < _datatype_size && _datatypes[index].name != NULL) {
            return _datatypes[index].name;
        } else {
            if(!dax_cdt_get(type, NULL)) {
                return _datatypes[index].name; 
            }
            return NULL;
        }
    } else {   
        switch (type) {
            case DAX_BOOL:
                return "BOOL";
            case DAX_BYTE:
                return "BYTE";
            case DAX_SINT:
                return "SINT";
            case DAX_WORD:
                return "WORD";
            case DAX_INT:
                return "INT";
            case DAX_UINT:
                return "UINT";
            case DAX_DWORD:
                return "DWORD";
            case DAX_DINT:
                return "DINT";
            case DAX_UDINT:
                return "UDINT";
            case DAX_TIME:
                return "TIME";
            case DAX_REAL:
                return "REAL";
            case DAX_LWORD:
                return "LWORD";
            case DAX_LINT:
                return "LINT";
            case DAX_ULINT:
                return "ULINT";
            case DAX_LREAL:
                return "LREAL";
        }
    }
    return NULL;
}

#define STATE_NAME     0x01
#define STATE_INDEX    0x02
#define STATE_IDLE     0x03
#define STATE_NEXT     0x04
#define STATE_FINISHED 0x00

#define TEST_SIZE 10

typedef struct {
    char name[DAX_TAGNAME_SIZE + 1];
    int index;
} _member_def;

static int
_parse_tagname(char *str, _member_def *list, int count)
{
    int n = 0, i = 0, j = 0, idx = 0;
    int state = STATE_NAME;
    char name[DAX_TAGNAME_SIZE + 1];
    char test[TEST_SIZE];
    int index = 0;
    
    /* TEST TEST TEST */
    printf("\nParsing '%s'\n", str);
    
    /* Initialize the list */
    for(n = 0; n < count; n++) {
        list[n].name[0] = '\0';
        list[n].index = -1;    
    }
    n = 0;
    
    while(str[n] != '\0' && state) {
        if(state == STATE_NAME) {          /* We start with tag searching state */
            if(str[n] == '[') {
                state = STATE_INDEX;      /* If we find a '[' switch to finding index */
            } else if(str[n] == '.') {
                state = STATE_NEXT;      /* If we find a '.' switch to the next name */
            } else {  /* Otherwise write the character to the tagname */
                if(n > DAX_TAGNAME_SIZE) { /* Check size */
                    return ERR_2BIG;
                }
                name[j++] = str[n];
                name[j] = '\0'; /* Just to make sure we have a NULL end */
            }
            if(str[n+1] == '\0') state = STATE_FINISHED;
            if(state != STATE_NAME) { /* If we have found the end of the tagname */
                strncpy(list[idx].name, name, DAX_TAGNAME_SIZE);
            }
        } else if(state == STATE_INDEX) { /* In this state we get the index */
            if(str[n] == '\0') {
                return ERR_PARSE;
            } else if(i > TEST_SIZE) {
                return ERR_2BIG;
            } else if(str[n] == ']') { /* get the index from the string */
                test[i] = '\0';
                list[idx].index = (int)strtol(test, NULL, 10);
                state = STATE_IDLE; /* This is so we'll go through the loop again */
            } else {
                if(i>=TEST_SIZE) { /* Too big for string */
                    return ERR_ARG;
                }
                test[i++] = str[n]; /* Add another character to the test string */
                test[i] = '\0';
            }
        } else if(state == STATE_NEXT) {
            idx++;
            i = j = 0;
            if(idx >= count) {
                return ERR_PARSE;
            }
            n--; /* Because this causes us one extra pass through the loop */
            state = STATE_NAME;
            
        /* We should only be idle for one character.  The only characters that
         * should follow the index are a '.' or the ending NULL.  If it's the
         * NULL we shouldn't ever get here.  If it's not the '.' then it's an error */
        } else if(state == STATE_IDLE) {
            if(str[n] == '.') {
                state = STATE_NEXT;
            } else {
                return ERR_ARG;
            }
        }
        n++;
    }
    /* Zero length tagname no good */
    if(n == 0) return ERR_TAG_BAD;
    
    /* Test the index that we found */
    if(index < 0) {
        return ERR_ARG;
    }

    return 0;
}

/* This function is used to determine a handle to the tag data area given
 * by the string.  It is a state machine of sorts.  It starts out looking for
 * the tagname itself.  Once it finds the end of the tagname it will either
 * have to find an index between brackets [] or a sub member following a '.'
 * It adds up all the indexes, makes sure that they are all within the bounds
 * of the tag and the datatype and then returns zero if successful and an
 * error code otherwise.
 */
int
dax_tag_handle(handle_t *h, char *str, int count)
{
    int n = 0;
    int cnt = 1;
    int result, byte, bit, index;
    _member_def *list;
    dax_tag tag;
    cdt_member *this;
    type_t type;
    
    /* Count the number of '.'s to figure out the size of the list */
    while(str[n] != '\0') {
        if(str[n] == '.') {
            cnt++;
        }
        n++;
    }
    list = malloc(sizeof(_member_def) * cnt);
    if(list == NULL) {
        result = ERR_ALLOC;
    }
    /* parse the given string into tokens and place in list */
    result = _parse_tagname(str, list, cnt);
    if(result) goto getout;
    /* At this point 'list' should contain all the tokens of the tag */
    
    result = dax_tag_byname(&tag, list[0].name);
    if(result) goto getout;
    
    //--TESTING
    printf("Found tag at index %d\n", tag.idx);
    
    byte = bit = 0;
    type = tag.type;
    
    /* This get's the initial offset of the tag itself */
    if(list[0].index > 0) {
        if(type == DAX_BOOL) {
            byte = list[0].index / 8;
            bit = list[0].index % 8;
        } else {
            byte = _get_typesize(type) * list[0].index;
        } 
    }
    
    for(n = 1; n < cnt; n++) {   
        if(IS_CUSTOM(type)) {
            /* We do this just to make sure that our type is in the cache */
            if(dax_type_to_string(type) == NULL) {
                result = ERR_ARG;
                goto getout;
            }
            /* If we make it this far then our type should work */
            index = CDT_TO_INDEX(type);
            this = _datatypes[index].members;
        
            while(this != NULL) {
                /* Start by adding all the bytes of the members before the
                 * one we are looking for */
                if(strcasecmp(list[n].name, this->name)) {
                    if(this->type == DAX_BOOL) {
                        byte += (this->count - 1)/8 + 1;
                    } else {
                        byte += _get_typesize(this->type) * this->count;
                    }
                } else { /* When we find it */
                    type = this->type;
                    break;
                }
                this = this->next;
            }
            if(this == NULL ) {
                result = ERR_NOTFOUND;
                goto getout;
            }
        } else {
            if(list[n].index > 0) {
                if(type == DAX_BOOL) {
                    byte = list[0].index / 8;
                    bit = list[0].index % 8;
                } else {
                    byte = _get_typesize(type) * list[0].index;
                } 
            }
        }
        
        printf("list[%d].name = %s : list[%d].index = %d\n", n, list[n].name, n, list[n].index);
    }
    /* TODO!!!! Still need to calculate the size */
    h->index = tag.idx;
    h->byte = byte;
    h->bit = bit;
    h->type = type;
    printf("Final Answer: byte = %d, bit = %d, type = %s\n", byte, bit, dax_type_to_string(type));
    
getout:
    if(list) free(list);
    return result;
}
